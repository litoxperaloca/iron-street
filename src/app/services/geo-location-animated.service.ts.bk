import { Injectable } from '@angular/core';
import { Geolocation, Position, PermissionStatus as Perm } from '@capacitor/geolocation';
import { MapService } from './map.service'; 
import { OsrmService } from './osrm.service';
import { TripService } from './trip.service';
import { TrafficAlertService } from './traffic-alert-service';
import { environment } from 'src/environments/environment';
import { GeoLocationService } from './geo-location.service';
import { SensorService } from './sensor.service';
import { MarkerAnimationService } from './marker-animation.service';
import { SpeedService } from './speed.service';
import { point } from '@turf/helpers';
import distance from '@turf/distance';
import bearing from '@turf/bearing';
import { MapboxGeoJSONFeature } from 'mapbox-gl';
import { Capacitor } from '@capacitor/core';
import { GeoLocationMockService } from '../mocks/geo-location-mock.service';
import { AlertService } from './alert.service';

@Injectable({
  providedIn: 'root'
})
export class GeoLocationAnimatedService {

  private watchId: string | null = null;
  private timeIdSimulation: any | null = null;
  private lastPosition!: Position | null;
  private lastHeading: number = 0;
  private lastCurrentStreet!: MapboxGeoJSONFeature | null;
  private geoLocPermIsOk: boolean = false;
  private lastPositionTime: number = 0; // Para sincronización del tiempo entre lecturas GPS

  constructor(
    private osrmService: OsrmService,
    private mapService: MapService,
    private tripService: TripService,
    private trafficAlertService: TrafficAlertService, 
    private markerAnimationService: MarkerAnimationService, 
    private geoLocationService: GeoLocationService, 
    private sensorService: SensorService, 
    private speedService: SpeedService,
    private geoLocationMockService: GeoLocationMockService,
    private alertService: AlertService
  ) {}

  public getLastPosition(): Position {
    return this.lastPosition!;
  }

  async getLocationPerm(): Promise<boolean> {
    const permissions = await Geolocation.checkPermissions();
    if (permissions.location !== 'granted') {
      const perm = await Geolocation.requestPermissions();
      if (perm.location !== 'granted') {
        await this.alertService.presentAlert(
          "Error: falta habilitar permiso para acceder a tu ubicación.",
          "Ubicación desactivada o permiso deshabilitado.",
          "Para poder utilizar esta app, permite que Iron Street acceda a tu ubicación. Dependiendo de tu dispositivo, es posible que debas abrir nuevamente la app después de habilitar el permiso.",
          ["OK (habilitarlo a continuación)"]
        );
        const permAgain = await Geolocation.requestPermissions();
        return permAgain.location === 'granted';
      }
      return true;
    }
    return true;
  }

  async getLocationPermWeb(): Promise<boolean> {
    const permissions = await navigator.permissions.query({ name: "geolocation" });
    if (permissions.state !== 'granted') {
      const permAgain = await navigator.permissions.query({ name: "geolocation" });
      if (permAgain.state !== 'granted') {
        await this.alertService.presentAlert(
          "Error: falta habilitar permiso para acceder a tu ubicación.",
          "Ubicación desactivada o permiso deshabilitado.",
          "Para poder utilizar esta app, permite que Iron Street acceda a tu ubicación.",
          ["OK (habilitarlo a continuación)"]
        );
        return false;
      }
      return true;
    }
    return true;
  }

  async requestPermissionsV2(): Promise<boolean> {
    if (Capacitor.isNativePlatform()) {
      return this.getLocationPerm();
    } else {
      return this.getLocationPermWeb();
    }
  }

  async requestPermissions(): Promise<boolean> {
    if (Capacitor.isNativePlatform()) {
      try {
        const permissions = await Geolocation.requestPermissions();
        return permissions.location === 'granted';
      } catch (error) {
        console.error('Error requesting location permissions', error);
        throw error;
      }
    } else {
      return true;
    }
  }

  // Inicia la observación de la posición del usuario
  public async startWatchingPosition(): Promise<void> {
    if (!this.geoLocPermIsOk) {
      this.geoLocPermIsOk = await this.requestPermissions();
    }

    if (this.geoLocPermIsOk) {
      const options = {
        enableHighAccuracy: true,
        timeout: environment.gpsSettings.timeOut,
        maximumAge: environment.gpsSettings.positionMaxAge,
      };

      if (Capacitor.isNativePlatform()) {
        this.watchId = await Geolocation.watchPosition(
          options,
          async (position, err) => {
            if (err) {
              console.error('Error obteniendo la posición:', err);
              return;
            }

            if (position) {
              await this.handlePositionUpdate(position);
            }
          }
        );
      } else {
        if (navigator.geolocation) {
          const id = navigator.geolocation.watchPosition(
            async (position: GeolocationPosition) => {
              const pos: Position = position as Position;
              await this.handlePositionUpdate(pos);
            },
            (err) => {
              console.error(`ERROR(${err.code}): ${err.message}`);
            },
            options
          );
          if (id != null) {
            this.watchId = id.toString();
          }
        }
      }
    }
  }

  // Maneja la actualización de la posición
  async handlePositionUpdate(position: Position): Promise<void> {
    const currentTime = Date.now();
    const timeSinceLastPosition = currentTime - this.lastPositionTime;

    // Filtrar posiciones según el tiempo (mínimo 1500ms, máximo 4000ms)
    if (timeSinceLastPosition < 1500 || timeSinceLastPosition > 4000) {
      //console.log(`Posición descartada: ${timeSinceLastPosition}ms`);
      return;
    }
    this.lastPositionTime = currentTime; // Actualiza el tiempo de la última posición

    const matchedPosition = await this.osrmService.getMatchedPosition(position);
    this.processMatchedPosition(matchedPosition);
  }

  async processMatchedPosition(matchedPosition: any): Promise<void> {
    this.speedService.setCurrentSpeed(matchedPosition.speed);
    this.speedService.setCurrentMaxSpeed(Number.parseInt(matchedPosition.maxspeed));

    const currentFeature = matchedPosition.currentFeature;
    const heading = matchedPosition.heading as number;

    const snapedPos = {
      coords: {
        longitude: matchedPosition.lon as number,
        latitude: matchedPosition.lat as number,
        heading: matchedPosition.heading as number,
        speed: matchedPosition.speed,
        altitude: matchedPosition.altitude,
        altitudeAccuracy: matchedPosition.altitudeAccuracy,
        accuracy: matchedPosition.accuracy,
      },
      timestamp: matchedPosition.timestamp,
    };

    let userMoved = this.hasMoved(
      [this.lastPosition?.coords.longitude!, this.lastPosition?.coords.latitude!],
      [snapedPos.coords.longitude, snapedPos.coords.latitude],
      snapedPos.coords.accuracy
    );

    this.lastHeading = heading;
    this.lastCurrentStreet = currentFeature;
    this.lastPosition = snapedPos;

    this.geoLocationService.setLastCurrentPosition(snapedPos);
    this.sensorService.setMatchedPosition(snapedPos, currentFeature, [snapedPos.coords.longitude, snapedPos.coords.latitude]);

    this.mapService.setStreetFeature(currentFeature);
    this.mapService.setUserCurrentStreet(currentFeature);

    if (this.mapService.isRotating) {
      const streetHeading = this.mapService.userCurrentStreetHeading;
      this.markerAnimationService.currentMarkerPosition = snapedPos;
      this.markerAnimationService.currentHeading = streetHeading;
      this.mapService.updateMarkerState(snapedPos, streetHeading, currentFeature);
      return;
    } 

    const promises = [];
    promises.push(this.markerAnimationService.updateUserMarker(snapedPos));

    if (this.mapService.isTripStarted) {
      promises.push(this.tripService.locationUpdate(false, matchedPosition));
    }

    if (matchedPosition.roadName && matchedPosition.cameras && matchedPosition.cameras.length > 0) {
      promises.push(this.trafficAlertService.checkAlertableObjectsOnNewUserPositionFromArray(snapedPos, matchedPosition.roadName, matchedPosition.cameras));
    }

    await Promise.all(promises);
  }

  // Detiene la observación de la posición
  async stopWatchingPosition() {
    if (this.watchId) {
      if (Capacitor.isNativePlatform()) {
        await Geolocation.clearWatch({ id: this.watchId });
      } else {
        navigator.geolocation.clearWatch(Number.parseInt(this.watchId));
      }
      this.watchId = null;
    }
  }

  // Calcula si el usuario ha cambiado de posición significativamente
  hasMoved(previousPosition: [number, number], currentPosition: [number, number], accuracy: number): boolean {
    const from = point(previousPosition);
    const to = point(currentPosition);
    const distanceInMeters = distance(from, to, { units: 'meters' });
    return distanceInMeters > environment.snapServiceConf.distanceToConsiderMovementInMeters && accuracy < environment.snapServiceConf.maxValidAccuracy;
  }

  // Predice la próxima posición
  predictNextPosition(currentPos: Position, speed: number, heading: number, deltaTimeMs: number): Position {
    const distanceTraveled = (speed * deltaTimeMs) / 1000;
    const radHeading = heading * (Math.PI / 180);
    const newLatitude = currentPos.coords.latitude + (distanceTraveled * Math.cos(radHeading)) / 111320;
    const newLongitude = currentPos.coords.longitude + (distanceTraveled * Math.sin(radHeading)) / (111320 * Math.cos(currentPos.coords.latitude * Math.PI / 180));

    return {
      ...currentPos,
      coords: {
        ...currentPos.coords,
        latitude: newLatitude,
        longitude: newLongitude,
      },
      timestamp: Date.now(),
    };
  }
}
